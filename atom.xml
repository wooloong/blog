<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>卧龙</title>
  
  <subtitle>龙——小则隐介藏形，大则兴云吐雾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wooloong.github.io/"/>
  <updated>2018-08-05T04:22:19.707Z</updated>
  <id>https://wooloong.github.io/</id>
  
  <author>
    <name>Wooloong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象编程——世界专车公司（一）：按接口编程</title>
    <link href="https://wooloong.github.io/2018/08/05/oop-interface/"/>
    <id>https://wooloong.github.io/2018/08/05/oop-interface/</id>
    <published>2018-08-05T04:23:01.000Z</published>
    <updated>2018-08-05T04:22:19.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p> 　　面向对象编程（简称:OOP）要求我们按人的思考方式来解决程序设计中的各类关联问题。这种编程的好处使得对象之间具有某种独立性，否则可能会奇怪的出现在你家里长期住着一个邋遢的陌生人的情景，而真实的世界是不应该有这样的情况的。这种好的独立性，使得对象之间必须联系的时候才进行联系，这会使得编写的代码易于重用、维护及扩展。</p><p>　　我们从简单工厂（Simple Factory）开始OOP的主题，为了形象的进行讲述，我们假想一家专车公司，称为世界专车公司（World Special Inc），我们想在这一行竞争中脱颖而出，成为世界第一（Number One），必须让我们的乘客客户获得更好，更快，更安全的服务。  </p><h2 id="按接口编程"><a href="#按接口编程" class="headerlink" title="按接口编程"></a>按接口编程</h2><p>　　<strong>说明</strong>：程序的代码往往都是同一个团队写的，修改代码对你们来说非常方便，从而很容易忽视面向对象编程的方式。记住程序里面表示的外界对象，要按它们的真实情景来思考。比如代表司机的Driver类，就应该按Driver类是司机的方式来思考自己本身及与其他对象的联系。<br>　　我们的专车公司当前有三类车：奔驰车（Bens）、宝马车（BWM， “别摸我”）、奥迪车（Audi），每辆车都会有一个车牌号（Plate No）。</p><p><strong>Bens :</strong>    </p><pre><code>package object.world.special;public class Bens {    private String plateNo ; // 车牌号码    public Bens(String plateNo){        this.plateNo = plateNo ;    }    public void openKey(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Bens车的锁打开了&quot;);    }    public void start(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Bens车启动了&quot;);    }    public void run(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Bens车在路上&quot;);    }    }</code></pre><p><strong>BWM :</strong>  </p><pre><code>package object.world.special;public class BWM {    private String plateNo ; // 车牌号码    public BWM(String plateNo){        this.plateNo = plateNo ;    }    public void openKey(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的BWM车的锁打开了&quot;);    }    public void start(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的BWM车启动了&quot;);    }    public void run(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的BWM车在路上&quot;);    }    }</code></pre><p><strong>Audi :</strong></p><pre><code>package object.world.special;public class Audi {    private String plateNo ; // 车牌号码    public Audi(String plateNo){        this.plateNo = plateNo ;    }    public void openKey(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Audi车的锁打开了&quot;);    }    public void start(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Audi车启动了&quot;);    }    public void run(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Audi车在路上&quot;);    }}</code></pre><p><strong>Driver（世界专车公司的司机员工）：</strong>   </p><pre><code>package object.world.special;public class Driver {    private String staffNo ; // 员工编号    private Bens bens ;    public Driver(String staffNo , Bens bens){        this.staffNo = staffNo;        this.bens = bens ;    }    public void drive(){        System.out.println(&quot;员工编号为 &quot;+ staffNo + &quot; 司机在驾驶汽车&quot;);        bens.openKey();        bens.start();        bens.run();    }    public void change(Bens otherBens){        bens = otherBens;    }}</code></pre><p><strong>乘客开始打专车服务：</strong></p><pre><code>package object.world.special;public class ModelClient {    public static void main(String[] args) {        // 一位驾驶 Bens（奔驰）的驾驶员        Driver driver = new Driver(&quot;WS0001&quot; ,new Bens(&quot;苏E10001&quot;));        driver.drive();        // 给司机换辆 Bens（奔驰）        driver.change(new Bens(&quot;苏E10002&quot;));        driver.drive();                    }}</code></pre><p>让我们看看输出的结果是什么？   </p><pre><code>员工编号为 WS0001 司机在驾驶汽车车牌号码 苏E10001 的Bens车的锁打开了车牌号码 苏E10001 的Bens车启动了车牌号码 苏E10001 的Bens车在路上-------- 人为的分割线 --------员工编号为 WS0001 司机在驾驶汽车车牌号码 苏E10002 的Bens车的锁打开了车牌号码 苏E10002 的Bens车启动了车牌号码 苏E10002 的Bens车在路上</code></pre><p>我们让司机换辆 BWM 上路 ：  <code>driver.change(new BWM(&quot;苏E80001&quot;));</code> 结果发现代码根本编译不过，因为从Driver类里注意到这个司机有一个Bens属性，这表明这司机其实只会驾驶Bens车。这显然不符合实际情况，不是我们所想要的，专车公司要的是会驾驶各类小汽车的员工。 </p><h3 id="设计原则：针对接口编程，而不是针对实现编程"><a href="#设计原则：针对接口编程，而不是针对实现编程" class="headerlink" title="设计原则：针对接口编程，而不是针对实现编程"></a>设计原则：针对接口编程，而不是针对实现编程</h3><p>　　我们修改代码，不应该把Driver驾驶的汽车类别固定死，而采用按接口编程。在Java语言里面，针对接口编程有两种方式：  </p><p><center><strong>1. 继承抽象超类(abstract super class)，关键字 extends</strong></center> <center><strong>2. 实现接口(interface)，关键字 implements</strong></center><br>　　一般如果有很多基本的方法（method）子类都可以通用，往往继承抽象超类的方式，把那些基本的方法放入抽象超类。我们在这里采用实现接口的方式来处理，引入一个 Car 接口，接口里面的方法都是抽象的，并且是 public 的， 实现接口里面的类的方法则会具有多态（polymorphic）性：执行时会按照实际状态来执行真正的行为（Java程序其实指的是方法）。接口 Car 可以这样设计：   </p><p><strong>Car：</strong>  </p><pre><code>package object.world.special;public interface Car {    void openKey();    void start();    void run();}</code></pre><p>我们发现接口里面的三个方法名与前面三类车的方法名是相同的，这是因为我们的类需要实现接口的缘故。修改后实现接口 Car 的 Bens 来看一下代码（BWM，Audi 一样处理）</p><p><strong> Bens：</strong>  </p><pre><code>package object.world.special;public class Bens implements Car{    private String plateNo ; // 车牌号码    public Bens(String plateNo){        this.plateNo = plateNo ;    }    public void openKey(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Bens车的锁打开了&quot;);    }    public void start(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Bens车启动了&quot;);    }    public void run(){        System.out.println(&quot;车牌号码 &quot; + plateNo + &quot; 的Bens车在路上&quot;);    }}</code></pre><p>　　只在 class 这一行添加了 <code>implements Car</code>，意思是要实现 Car 里面的方法，这三个方法一开始就有了，如果 Car 添加新的方法，则 Bens 需要添加同样方法名的方法来实现。这样Bens（奔驰）、BWM（宝马）、Audi（奥迪）针对 Car 接口都有了自己不同的实现。<br>　　接下来要修改Driver（司机）类，让司机会驾驶所有的小汽车（Car），把 Bens 替换为 Car 即可。<br><strong>Driver：</strong>   </p><pre><code>package object.world.special;public class Driver {    private String staffNo ; // 员工编号    private Car car ;    public Driver(String staffNo , Car car){        this.staffNo = staffNo;        this.car = car ;    }    public void drive(){        System.out.println(&quot;员工编号为 &quot;+ staffNo + &quot; 司机在驾驶汽车&quot;);        car.openKey();        car.start();        car.run();    }    public void change(Car otherCar){        car = otherCar;    }}</code></pre><p><strong>乘客继承打专车服务：</strong>    </p><pre><code>package object.world.special;public class ModelClient {    public static void main(String[] args) {        // 一位驾驶 Bens（奔驰）的驾驶员        Driver driver = new Driver(&quot;WS0001&quot; ,new Bens(&quot;苏E10001&quot;));        driver.drive();        // 给司机换辆 Bens（奔驰）        driver.change(new Bens(&quot;苏E10002&quot;));        driver.drive();            // === 新添加的代码 ===        // 给司机换辆 BWM（别摸我）        driver.change(new BWM(&quot;苏E80001&quot;));        driver.drive();        // 给司机换辆 Audi（奥迪）        driver.change(new Audi(&quot;苏E60001&quot;));        driver.drive();                }}　</code></pre><p> 先让我们看看这次输出的结果是什么？   </p><pre><code>员工编号为 WS0001 司机在驾驶汽车车牌号码 苏E10001 的Bens车的锁打开了车牌号码 苏E10001 的Bens车启动了车牌号码 苏E10001 的Bens车在路上-------- 人为的分割线 --------员工编号为 WS0001 司机在驾驶汽车车牌号码 苏E10002 的Bens车的锁打开了车牌号码 苏E10002 的Bens车启动了车牌号码 苏E10002 的Bens车在路上---- 人为的分割线 ，底下为新的代码 ----员工编号为 WS0001 司机在驾驶汽车车牌号码苏E80001的BWM车的锁打开了车牌号码苏E80001的BWM车启动了车牌号码苏E80001的BWM车在路上-------- 人为的分割线 --------员工编号为 WS0001 司机在驾驶汽车车牌号码苏E60001的Audi车的锁打开了车牌号码苏E60001的Audi车启动了车牌号码苏E60001的Audi车在路上</code></pre><p>　　我们发现 ModelClient类的main方法 前面的代码并不需要做任何修改，另外这三类车，Driver 里面的 Car 属性都能够接受，同样是 <code>driver.drive();</code> 的代码，然而可以根据具体是什么车来实现相应的行为，宝马车（BMW）展示的就是宝马车的行为，奥迪车（Audi）展示的就是奥迪车的行为，这就是接口编程的好处，使得司机轻松驾驶每一种类型的车。</p><h6 id="参考-："><a href="#参考-：" class="headerlink" title="参考 ："></a>参考 ：</h6><blockquote><p>Head First 设计模式（中文版）—— 中国电力出版社 ISBN：978-7-508-35393-7</p></blockquote><hr><h2 id="下一讲：我们来讲述简单工厂（Simple-Factory）的主题"><a href="#下一讲：我们来讲述简单工厂（Simple-Factory）的主题" class="headerlink" title="下一讲：我们来讲述简单工厂（Simple Factory）的主题"></a>下一讲：我们来讲述简单工厂（Simple Factory）的主题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt; 　　面向对象编程（简称:OOP）要求我们按人的思考方式来解决程序设计中的各类关联问题。这种编程的好处使得对象之间具有某种独立性，否则可能会
      
    
    </summary>
    
      <category term="面向对象编程" scheme="https://wooloong.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://wooloong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>我的博客（My Blog）, Welcome!</title>
    <link href="https://wooloong.github.io/2018/07/22/markdown-1/"/>
    <id>https://wooloong.github.io/2018/07/22/markdown-1/</id>
    <published>2018-07-22T12:26:58.000Z</published>
    <updated>2018-07-29T13:23:25.406Z</updated>
    
    <content type="html"><![CDATA[<p>用<a href="https://github.com/" title="GitHub" target="_blank" rel="noopener">GitHub</a>技术，加上功能强大的博客框架（powerful blog framework）<a href="https://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>,搭建了我的个人博客。<br>国内用户可访问链接 <a href="https://wooloong.coding.me/" title="wooloong的博客" target="_blank" rel="noopener">https://wooloong.coding.me/</a>.<br>国外用户可访问链接 <a href="https://wooloong.github.io/" title="wooloong的博客">https://wooloong.github.io/</a>.  </p><p>感谢大家的捧场，定期会发布一些有一定深度的技术文章与专题，供大家学习、研究与讨论。<br>今天简单讲讲非常好用的写博客的标识性语言——Markdown语言。</p><h2 id="Markdown语言"><a href="#Markdown语言" class="headerlink" title="Markdown语言"></a>Markdown语言</h2><p>以下是一段Markdown语言写的文本，效果样式展示在后面。<br><strong>Markdown文本如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 标题1</span><br><span class="line">## 标题2</span><br><span class="line">### 标题3（依次类推）</span><br><span class="line"></span><br><span class="line">* 无序列表</span><br><span class="line">* 无序列表</span><br><span class="line">* 无序列表  </span><br><span class="line">1. 列表1</span><br><span class="line">2. 列表2</span><br><span class="line">3. 列表3  </span><br><span class="line"></span><br><span class="line">*斜体*  </span><br><span class="line">**黑体**  </span><br><span class="line">` 代码 `</span><br><span class="line"></span><br><span class="line">[百度链接](https://www.baidu.com/)</span><br><span class="line">--- </span><br><span class="line">天安门图片：  </span><br><span class="line">![](http://pic0.huitu.com/res/20180613/1782557_20180613183716491149_1.jpg)</span><br></pre></td></tr></table></figure></p><p><strong>效果样式展示 ：</strong></p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3（依次类推）"><a href="#标题3（依次类推）" class="headerlink" title="标题3（依次类推）"></a>标题3（依次类推）</h3><ul><li>无序列表</li><li>无序列表</li><li>无序列表  </li></ul><ol><li>列表1</li><li>列表2</li><li>列表3  </li></ol><p><em>斜体</em><br><strong>黑体</strong><br><code>代码</code></p><h2 id="百度链接"><a href="#百度链接" class="headerlink" title="百度链接"></a><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度链接</a></h2><p>天安门图片：<br><img src="http://pic0.huitu.com/res/20180613/1782557_20180613183716491149_1.jpg" alt="">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用&lt;a href=&quot;https://github.com/&quot; title=&quot;GitHub&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;技术，加上功能强大的博客框架（powerful blog framework）&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="Markdown" scheme="https://wooloong.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
